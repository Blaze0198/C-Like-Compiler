
# C-like Compiler Using Flex and Bison

## Overview
This project implements a simplified C-like language compiler using Flex and Bison. The language retains many core features of classic C, such as variable declarations, arrays, pointers, and control flow, but simplifies syntax and eliminates certain complexities like dynamic memory allocation and external libraries.

## Key Features
- **Keywords and Data Types**: Supports standard data types such as `char`, `int`, `float`, `double`, and `boolean`.
- **No Imports**: The language does not allow importing external libraries, simplifying the compilation process.
- **Static Memory Allocation**: All memory is allocated statically, with no dynamic memory allocation.
- **Simplified Lexical Analysis**: Uses regular expressions for tokenizing source code through Flex.
- **Parser Integration**: Bison is used for syntax analysis, constructing the grammar rules for parsing.
- **Symbol Table**: A symbol table manages variable and function declarations, with efficient scope and type checking.
- **Semantic Analysis**: Includes static type checking for variables, function parameters, and expressions.

## Tools Used
- **Flex**: Generates the lexical analyzer to convert the input source code into tokens.
- **Bison**: Generates the parser, which applies grammar rules to the tokenized input.
- **GCC**: The C compiler used to compile the generated lexer and parser code.

## Compilation Instructions
1. Install `Flex` and `Bison` on your system.
2. Generate the lexer using Flex:
   ```
   flex lexer.l
   ```
3. Generate the parser using Bison:
   ```
   bison -d parser.y
   ```
4. Compile the generated C code:
   ```
   gcc lex.yy.c parser.tab.c -o compiler
   ```
5. Run the compiler with an input file:
   ```
   ./compiler input_file.c
   ```

## How It Works
1. **Lexical Analysis**: The input source code is first tokenized by the lexer generated by Flex.
2. **Parsing**: The parser, generated by Bison, applies grammar rules to the tokens and constructs an abstract syntax tree (AST).
3. **Symbol Table**: Manages all declared variables, functions, and their scopes.
4. **Semantic Analysis**: Performs static type checking and ensures compatibility of function parameters, variable declarations, and expressions.
5. **Output**: After successful parsing and analysis, the compiler generates output detailing the symbol table and any semantic errors.

## File Structure
- `lexer.l`: Flex file containing token definitions and regular expressions.
- `parser.y`: Bison file containing grammar rules and actions.
- `symtab.c`: Contains the symbol table implementation.
- `semantics.c`: Implements semantic analysis for the compiler.

## Example Code (Input File)
```c
int a;
int b = 5;
int *p;
if (b > 3) {
    a = b;
}
```

## Authors
- Gogineni Ashrith Sai
- Konda Reddy Balaji Reddy
- Thanakanti Ganesh Madhav


